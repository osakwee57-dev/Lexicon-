
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { createRoot } from 'react-dom/client';

// --- Configuration & Constants ---

const SCRABBLE_SCORES: Record<string, number> = {
  A: 1, B: 3, C: 3, D: 2, E: 1, F: 4, G: 2, H: 4, I: 1, J: 8, K: 5, L: 1, M: 3,
  N: 1, O: 1, P: 3, Q: 10, R: 1, S: 1, T: 1, U: 1, V: 4, W: 4, X: 8, Y: 4, Z: 10
};

type Difficulty = 'Easy' | 'Medium' | 'Hard';

interface WordEntry {
  word: string;
  definition: string;
}

const LOCAL_DICTIONARY: Record<Difficulty, WordEntry[]> = {
  Easy: [
    { word: "APPLE", definition: "A round fruit with red or green skin and a whitish inside." },
    { word: "BREAD", definition: "Food made of flour, water, and yeast or another leavening agent, mixed together and baked." },
    { word: "CHAIR", definition: "A separate seat for one person, typically with a back and four legs." },
    { word: "DANCE", definition: "Move rhythmically to music, typically following a set sequence of steps." },
    { word: "EAGLE", definition: "A large bird of prey with a massive hooked bill and long broad wings." },
    { word: "FLAME", definition: "A hot glowing body of ignited gas that is generated by something on fire." },
    { word: "GRASS", definition: "Vegetation consisting of typically short plants with long narrow leaves, growing wild or cultivated." },
    { word: "HAPPY", definition: "Feeling or showing pleasure or contentment." },
    { word: "IMAGE", definition: "A representation of the external form of a person or thing in art." },
    { word: "JUMP", definition: "Push oneself off a surface and into the air by using the muscles in one's legs and feet." },
    { word: "KITE", definition: "A toy consisting of a light frame with thin material stretched over it, flown in the wind." },
    { word: "LEMON", definition: "A yellow, oval citrus fruit with thick skin and fragrant, acidic juice." },
    { word: "MOUSE", definition: "A small rodent that typically has a pointed snout, relatively large ears and eyes, and a long tail." },
    { word: "NIGHT", definition: "The period of darkness in each twenty-four hours; the time from sunset to sunrise." },
    { word: "OCEAN", definition: "A very large expanse of sea, in particular each of the main areas into which the sea is divided." },
    { word: "PIANO", definition: "A large keyboard musical instrument with a wooden case enclosing a soundboard and metal strings." },
    { word: "QUEEN", definition: "The female ruler of an independent state, especially one who inherits the position by right of birth." },
    { word: "RIVER", definition: "A large natural stream of water flowing in a channel to the sea, a lake, or another such stream." },
    { word: "SMILE", definition: "Form one's features into a pleased, kind, or amused expression, typically with the corners of the mouth turned up." },
    { word: "TABLE", definition: "A piece of furniture with a flat top and one or more legs, providing a level surface on which objects may be placed." },
    { word: "UNCLE", definition: "The brother of one's father or mother or the husband of one's aunt." },
    { word: "VOICE", definition: "The sound produced in a person's larynx and uttered through the mouth, as speech or song." },
    { word: "WATER", definition: "A colorless, transparent, odorless liquid that forms the seas, lakes, rivers, and rain." },
    { word: "ZEBRA", definition: "An African wild horse with black-and-white stripes and an erect mane." }
  ],
  Medium: [
    { word: "BRIDGE", definition: "A structure carrying a road, path, railroad, or canal across a river, ravine, road, railroad, or other obstacle." },
    { word: "CANYON", definition: "A deep gorge, typically one with a river flowing through it." },
    { word: "DESERT", definition: "A dry, barren area of land, especially one covered with sand, that is characteristically waterless and without vegetation." },
    { word: "FOREST", definition: "A large area covered chiefly with trees and undergrowth." },
    { word: "GALAXY", definition: "A system of millions or billions of stars, together with gas and dust, held together by gravitational attraction." },
    { word: "HARBOR", definition: "A place on the coast where vessels may find shelter, especially one protected from rough water by piers, jetties, and other artificial structures." },
    { word: "ISLAND", definition: "A piece of land surrounded by water." },
    { word: "JUNGLE", definition: "An area of land overgrown with dense forest and tangled vegetation, typically in the tropics." },
    { word: "KNIGHT", definition: "A man who served his sovereign or lord as a mounted soldier in armor." },
    { word: "LIZARD", definition: "A reptile that typically has a long body and tail, four legs, movable eyelids, and a rough, scaly, or spiny skin." },
    { word: "MAGNET", definition: "A piece of iron (or an ore, alloy, or other material) that has its component atoms so ordered that the material exhibits properties of magnetism." },
    { word: "NEBULA", definition: "A cloud of gas and dust in outer space, visible in the night sky either as an indistinct bright patch or as a dark silhouette against other luminous matter." },
    { word: "ORANGE", definition: "A round juicy citrus fruit with a tough bright reddish-yellow rind." },
    { word: "PIRATE", definition: "A person who attacks and robs ships at sea." },
    { word: "QUARTZ", definition: "A hard white or colorless mineral consisting of silicon dioxide, found widely in igneous, metamorphic, and sedimentary rocks." },
    { word: "ROCKET", definition: "A cylindrical projectile that can be propelled to a great height or distance by the combustion of its contents." },
    { word: "SHIELD", definition: "A broad piece of metal or another suitable material, held by straps or a handle attached on one side, used as a protection against blows or missiles." },
    { word: "TEMPLE", definition: "A building devoted to the worship, or regarded as the dwelling place, of a god or gods or other objects of religious reverence." },
    { word: "VALLEY", definition: "A low area of land between hills or mountains, typically with a river or stream flowing through it." },
    { word: "WIZARD", definition: "A man who has magical powers, especially in legends and fairy tales." },
    { word: "YELLOW", definition: "The color between green and orange in the spectrum, a primary subtractive color complementary to blue." },
    { word: "ZODIAC", definition: "A belt of the heavens within about 8Â° either side of the ecliptic, including all apparent positions of the sun, moon, and most familiar planets." },
    { word: "DOCTOR", definition: "A qualified practitioner of medicine; a physician." },
    { word: "PLANET", definition: "A celestial body moving in an elliptical orbit around a star." }
  ],
  Hard: [
    { word: "ABYSS", definition: "A deep or seemingly bottomless chasm." },
    { word: "BIZARRE", definition: "Very strange or unusual, especially so as to cause interest or amusement." },
    { word: "CRYPTIC", definition: "Having a meaning that is mysterious or obscure." },
    { word: "DRASTIC", definition: "Likely to have a strong or far-reaching effect; radical and extreme." },
    { word: "ECLIPSE", definition: "An obscuring of the light from one celestial body by the passage of another between it and the observer or between it and its source of illumination." },
    { word: "FISSURE", definition: "A long, narrow opening or line of breakage made by cracking or splitting, especially in rock or earth." },
    { word: "GLACIER", definition: "A slowly moving mass or river of ice formed by the accumulation and compaction of snow on mountains or near the poles." },
    { word: "HORIZON", definition: "The line at which the earth's surface and the sky appear to meet." },
    { word: "ILLUSION", definition: "A thing that is or is likely to be wrongly perceived or interpreted by the senses." },
    { word: "JUBILEE", definition: "A special anniversary of an event, especially one celebrating twenty-five or fifty years of a reign or activity." },
    { word: "KINETIC", definition: "Relating to or resulting from motion." },
    { word: "LABYRINTH", definition: "A complicated irregular network of passages or paths in which it is difficult to find one's way; a maze." },
    { word: "MYSTERY", definition: "Something that is difficult or impossible to understand or explain." },
    { word: "NOSTALGIA", definition: "A sentimental longing or wistful affection for the past, typically for a period or place with happy personal associations." },
    { word: "OBSIDIAN", definition: "A hard, dark, glasslike volcanic rock formed by the rapid solidification of lava without crystallization." },
    { word: "PHOENIX", definition: "A unique bird that lived for five or six centuries in the Arabian desert, after this time burning itself on a funeral pyre and rising from the ashes with renewed youth." },
    { word: "QUANTUM", definition: "A discrete quantity of energy proportional in magnitude to the frequency of the radiation it represents." },
    { word: "RHYTHM", definition: "A strong, regular, repeated pattern of movement or sound." },
    { word: "SYMPHONY", definition: "An elaborate musical composition for full orchestra, typically in four movements." },
    { word: "TSUNAMI", definition: "A long high sea wave caused by an earthquake, submarine landslide, or other disturbance." },
    { word: "UTOPIA", definition: "An imagined place or state of things in which everything is perfect." },
    { word: "VORTEX", definition: "A mass of whirling fluid or air, especially a whirlpool or whirlwind." },
    { word: "WHISPER", definition: "Speak very softly using one's breath without one's vocal cords, especially for the sake of privacy." },
    { word: "ZEPHYR", definition: "A soft gentle breeze." }
  ]
};

// --- Styles ---

const styles = `
  :root {
    --bg-color: #2e8b57; /* Sea Green / Felt Green */
    --tile-color: #f4e7d1;
    --tile-shadow: #d9cba8;
    --wood-color: #8b5a2b;
    --wood-dark: #5c3a1b;
    --text-main: #ffffff;
    --accent: #f9a825;
    --danger: #e57373;
  }

  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: var(--bg-color);
    color: var(--text-main);
    display: flex;
    justify-content: center;
    min-height: 100vh;
    overflow-x: hidden;
  }

  .app-container {
    width: 100%;
    max-width: 600px;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    box-sizing: border-box;
  }

  /* Header & Score */
  .header {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-bottom: 30px;
    background: rgba(0, 0, 0, 0.2);
    padding: 15px 20px;
    border-radius: 12px;
    backdrop-filter: blur(5px);
  }

  .header-top {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
  }

  .game-title {
    font-size: 1.5rem;
    font-weight: 800;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    letter-spacing: 1px;
    color: var(--accent);
  }

  .score-board {
    font-size: 1.2rem;
    font-weight: bold;
  }

  .level-selector {
    display: flex;
    gap: 10px;
    align-items: center;
    font-size: 0.9rem;
    color: rgba(255,255,255,0.8);
  }

  .level-select {
    background: rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.2);
    color: white;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-family: inherit;
  }

  .level-select:focus {
    outline: none;
    border-color: var(--accent);
  }

  /* Definition Area */
  .definition-card {
    background: white;
    color: #333;
    padding: 25px;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    margin-bottom: 40px;
    width: 100%;
    text-align: center;
    position: relative;
    min-height: 100px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }

  .definition-label {
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: #888;
    margin-bottom: 10px;
  }

  .definition-text {
    font-size: 1.2rem;
    line-height: 1.5;
    font-weight: 500;
  }

  /* Board Area (Slots) */
  .board-area {
    display: flex;
    gap: 8px;
    margin-bottom: 40px;
    flex-wrap: wrap;
    justify-content: center;
    min-height: 60px;
  }

  .slot {
    width: 50px;
    height: 50px;
    background: rgba(0,0,0,0.15);
    border-radius: 6px;
    border: 2px solid rgba(255,255,255,0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .slot.filled {
    border-color: transparent;
    background: transparent;
  }

  /* Tile Styling */
  .tile {
    width: 48px;
    height: 48px;
    background: var(--tile-color);
    border-radius: 6px;
    box-shadow: 0 4px 0 var(--tile-shadow), 0 5px 5px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    color: #333;
    user-select: none;
    transform: translateY(0);
    transition: transform 0.1s, box-shadow 0.1s;
    cursor: pointer;
  }
  
  .tile.locked {
    filter: brightness(0.95);
    cursor: default;
  }

  .tile:active {
    transform: translateY(4px);
    box-shadow: 0 0 0 var(--tile-shadow), 0 0 0 rgba(0,0,0,0);
  }

  .tile-letter {
    font-size: 1.6rem;
    font-weight: 700;
    line-height: 1;
  }

  .tile-score {
    position: absolute;
    bottom: 3px;
    right: 4px;
    font-size: 0.6rem;
    font-weight: 600;
  }

  /* Rack Area */
  .rack-container {
    background: linear-gradient(to bottom, var(--wood-color), var(--wood-dark));
    padding: 15px 25px 20px;
    border-radius: 4px;
    box-shadow: 0 10px 20px rgba(0,0,0,0.4);
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
    width: fit-content;
    min-width: 300px;
    min-height: 80px;
    align-items: center;
    margin-bottom: 30px;
    position: relative;
  }
  
  .rack-container::after {
    content: '';
    position: absolute;
    bottom: -10px;
    left: 10px;
    right: 10px;
    height: 10px;
    background: rgba(0,0,0,0.3);
    border-radius: 50%;
    filter: blur(5px);
    z-index: -1;
  }

  /* Buttons & Controls */
  .controls {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .btn {
    padding: 12px 24px;
    border: none;
    border-radius: 25px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.1s, opacity 0.2s;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .btn:active {
    transform: scale(0.95);
  }

  .btn-primary {
    background: var(--accent);
    color: #3e2700;
  }
  
  .btn-secondary {
    background: rgba(255,255,255,0.2);
    color: white;
  }
  
  .btn-hint {
    background: #ffb74d;
    color: #4e342e;
  }

  .btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .message {
    height: 20px;
    margin-bottom: 10px;
    color: var(--accent);
    font-weight: bold;
    text-align: center;
  }

  .loader {
    width: 30px;
    height: 30px;
    border: 4px solid #fff;
    border-bottom-color: transparent;
    border-radius: 50%;
    animation: rotation 1s linear infinite;
    margin: 20px auto;
  }

  @keyframes rotation {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .api-warning {
    background: #ff5252;
    color: white;
    padding: 10px;
    border-radius: 8px;
    margin-top: 20px;
    text-align: center;
    max-width: 400px;
  }
  
  .shuffle-btn {
    position: absolute;
    right: -40px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: rgba(255,255,255,0.6);
    cursor: pointer;
    font-size: 1.5rem;
  }
  
  .shuffle-btn:hover {
    color: white;
  }
  
  .seen-count {
    position: absolute;
    bottom: -25px;
    right: 0;
    font-size: 0.7rem;
    color: rgba(255,255,255,0.5);
  }
  
  /* Confetti-ish animation for win */
  @keyframes pop {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }
  
  .win-anim {
    animation: pop 0.3s ease-in-out;
  }
`;

// --- Types ---

interface Tile {
  id: string;
  letter: string;
  value: number;
  isHint?: boolean;
}

interface GameState {
  word: string;
  definition: string;
  placedTiles: (Tile | null)[];
  rackTiles: Tile[];
  status: 'loading' | 'playing' | 'won' | 'error';
  score: number;
  totalScore: number;
  message: string;
  seenWords: string[];
  difficulty: Difficulty;
}

// --- Logic ---

function shuffleArray<T>(array: T[]): T[] {
  const newArr = [...array];
  for (let i = newArr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
  }
  return newArr;
}

function generateTiles(word: string): Tile[] {
  return word.toUpperCase().split('').map((char, index) => ({
    id: `${char}-${index}-${Math.random()}`,
    letter: char,
    value: SCRABBLE_SCORES[char] || 0
  }));
}

const App = () => {
  const [gameState, setGameState] = useState<GameState>({
    word: '',
    definition: '',
    placedTiles: [],
    rackTiles: [],
    status: 'loading',
    score: 0,
    totalScore: 0,
    message: '',
    seenWords: [],
    difficulty: 'Medium'
  });
  
  const seenWordsRef = useRef<string[]>([]);
  const difficultyRef = useRef<Difficulty>('Medium'); // Keep ref to use inside callback

  const fetchNewWord = useCallback(async () => {
    // Reset board but keep score and difficulty
    setGameState(prev => ({ 
      ...prev, 
      status: 'loading', 
      message: '', 
      placedTiles: [], 
      rackTiles: [], 
      word: '', 
      definition: '' 
    }));
    
    // Simulate loading to feel like a game processing
    await new Promise(resolve => setTimeout(resolve, 500));

    try {
      const currentDifficulty = difficultyRef.current;
      const candidates = LOCAL_DICTIONARY[currentDifficulty];
      
      // Filter out recently seen words to avoid immediate repetition
      // In a real app with 300k words, we might track more.
      // With this smaller offline set, we just try to avoid the last 5.
      const available = candidates.filter(c => !seenWordsRef.current.slice(-5).includes(c.word));
      
      const pool = available.length > 0 ? available : candidates;
      
      const randomEntry = pool[Math.floor(Math.random() * pool.length)];
      
      const word = randomEntry.word.toUpperCase();
      const definition = randomEntry.definition;
      
      const tiles = generateTiles(word);
      const shuffledTiles = shuffleArray(tiles);

      seenWordsRef.current = [...seenWordsRef.current, word];

      setGameState(prev => ({
        ...prev,
        word: word,
        definition: definition,
        placedTiles: Array(word.length).fill(null),
        rackTiles: shuffledTiles,
        status: 'playing',
        score: 0,
        seenWords: [...prev.seenWords, word],
        difficulty: currentDifficulty
      }));

    } catch (error) {
      console.error(error);
      setGameState(prev => ({ ...prev, status: 'error', message: 'Something went wrong.' }));
    }
  }, []);

  useEffect(() => {
    // Initial fetch
    fetchNewWord();
  }, [fetchNewWord]);

  // Interaction Handlers
  const handleRackTileClick = (tile: Tile) => {
    if (gameState.status !== 'playing') return;

    // Find first empty slot
    const firstEmptyIndex = gameState.placedTiles.findIndex(t => t === null);
    if (firstEmptyIndex === -1) return; // No space

    const newPlaced = [...gameState.placedTiles];
    newPlaced[firstEmptyIndex] = tile;

    const newRack = gameState.rackTiles.filter(t => t.id !== tile.id);

    // Calculate current score of placed tiles
    const currentScore = newPlaced.reduce((acc, t) => acc + (t ? t.value : 0), 0);

    setGameState(prev => ({
      ...prev,
      placedTiles: newPlaced,
      rackTiles: newRack,
      score: currentScore
    }));
    
    checkWinCondition(newPlaced, gameState.word);
  };

  const handlePlacedTileClick = (index: number) => {
    if (gameState.status !== 'playing') return;
    
    const tile = gameState.placedTiles[index];
    if (!tile) return;
    if (tile.isHint) return; // Cannot move hint tiles

    const newPlaced = [...gameState.placedTiles];
    newPlaced[index] = null;

    const newRack = [...gameState.rackTiles, tile];
    
    // Update score
    const currentScore = newPlaced.reduce((acc, t) => acc + (t ? t.value : 0), 0);

    setGameState(prev => ({
      ...prev,
      placedTiles: newPlaced,
      rackTiles: newRack,
      score: currentScore
    }));
  };

  const useHint = () => {
    if (gameState.status !== 'playing') return;
    
    const { word, placedTiles, rackTiles } = gameState;
    
    // Find first slot that is incorrect or empty
    let targetIndex = -1;
    for (let i = 0; i < word.length; i++) {
        if (!placedTiles[i] || placedTiles[i]?.letter !== word[i]) {
            targetIndex = i;
            break;
        }
    }

    if (targetIndex === -1) return; // Already solved mostly?

    const targetLetter = word[targetIndex];
    let tileToMove: Tile | undefined;
    let newRack = [...rackTiles];
    let newPlaced = [...placedTiles];
    
    // 1. Look in Rack
    const rackIndex = newRack.findIndex(t => t.letter === targetLetter);
    if (rackIndex !== -1) {
        tileToMove = newRack[rackIndex];
        newRack.splice(rackIndex, 1);
    } else {
        // 2. Look in Placed (incorrectly placed somewhere else)
        // Find a tile with the letter that ISN'T in the correct spot
        const placedIndex = newPlaced.findIndex((t, idx) => 
            t?.letter === targetLetter && (idx !== targetIndex && newPlaced[idx]?.letter !== word[idx])
        );
        
        if (placedIndex !== -1) {
            tileToMove = newPlaced[placedIndex]!;
            newPlaced[placedIndex] = null; // Remove from old spot
        }
    }

    if (tileToMove) {
        // Mark as hint so it can't be moved back
        const hintTile = { ...tileToMove, isHint: true };
        
        // If there was something in the target slot (incorrect tile), move it back to rack
        if (newPlaced[targetIndex]) {
            newRack.push(newPlaced[targetIndex]!);
        }

        newPlaced[targetIndex] = hintTile;
        
        // Deduct points from total score
        setGameState(prev => ({
            ...prev,
            placedTiles: newPlaced,
            rackTiles: newRack,
            totalScore: prev.totalScore - 5,
            message: 'Hint Used! -5 Points'
        }));

        setTimeout(() => setGameState(prev => ({...prev, message: ''})), 1500);

        // Check if this solved it
        checkWinCondition(newPlaced, word);
    }
  };

  const shuffleRack = () => {
    setGameState(prev => ({
      ...prev,
      rackTiles: shuffleArray(prev.rackTiles)
    }));
  };

  const checkWinCondition = (currentPlaced: (Tile | null)[], targetWord: string) => {
    if (currentPlaced.some(t => t === null)) return;

    const formedWord = currentPlaced.map(t => t?.letter).join('');
    
    if (formedWord === targetWord) {
      const wordScore = currentPlaced.reduce((acc, t) => acc + (t ? t.value : 0), 0);
      
      setGameState(prev => ({
        ...prev,
        status: 'won',
        message: `Correct! +${wordScore} points`,
        totalScore: prev.totalScore + wordScore
      }));
    } else {
      setGameState(prev => ({
        ...prev,
        message: 'Not quite...'
      }));
      setTimeout(() => {
         setGameState(prev => ({ ...prev, message: '' }));
      }, 2000);
    }
  };

  const handleDifficultyChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const newDiff = e.target.value as Difficulty;
    setGameState(prev => ({ ...prev, difficulty: newDiff }));
    difficultyRef.current = newDiff;
    // Don't auto fetch, let user finish or skip
  };

  const skipWord = () => {
    fetchNewWord();
  };

  return (
    <>
      <style>{styles}</style>
      <div className="app-container">
        
        <header className="header">
          <div className="header-top">
             <div className="game-title">LEXICON</div>
             <div className="score-board">Score: {gameState.totalScore}</div>
          </div>
          
          <div className="level-selector">
             <span>Difficulty:</span>
             <select 
               className="level-select" 
               value={gameState.difficulty} 
               onChange={handleDifficultyChange}
               disabled={gameState.status === 'loading'}
             >
               <option value="Easy">Easy (4-5 letters)</option>
               <option value="Medium">Medium (6-7 letters)</option>
               <option value="Hard">Hard (8-10 letters)</option>
             </select>
          </div>
        </header>

        {gameState.status === 'error' && (
           <div className="api-warning">
             {gameState.message} <br/>
             <button className="btn btn-secondary" style={{marginTop: 10}} onClick={fetchNewWord}>Retry</button>
           </div>
        )}

        {gameState.status === 'loading' ? (
          <div className="loader"></div>
        ) : (
          gameState.status !== 'error' && (
            <>
              <div className="definition-card">
                <div className="definition-label">Definition</div>
                <div className="definition-text">
                  {gameState.definition}
                </div>
              </div>

              <div className="board-area">
                {gameState.placedTiles.map((tile, index) => (
                  <div 
                    key={`slot-${index}`} 
                    className={`slot ${tile ? 'filled' : ''}`}
                    onClick={() => handlePlacedTileClick(index)}
                  >
                    {tile && (
                      <div className={`tile ${tile.isHint ? 'locked' : ''} ${gameState.status === 'won' ? 'win-anim' : ''}`}>
                        <span className="tile-letter">{tile.letter}</span>
                        <span className="tile-score">{tile.value}</span>
                      </div>
                    )}
                  </div>
                ))}
              </div>

              <div className="message">{gameState.message}</div>

              {gameState.status === 'won' ? (
                 <div className="controls">
                   <button className="btn btn-primary" onClick={fetchNewWord}>Next Word â†’</button>
                 </div>
              ) : (
                <div className="rack-container">
                   <div className="seen-count">Offline Mode</div>
                   {gameState.rackTiles.length > 0 && (
                     <button className="shuffle-btn" onClick={shuffleRack} title="Shuffle">
                       â†»
                     </button>
                   )}
                   {gameState.rackTiles.map((tile) => (
                     <div 
                       key={tile.id} 
                       className="tile"
                       onClick={() => handleRackTileClick(tile)}
                     >
                       <span className="tile-letter">{tile.letter}</span>
                       <span className="tile-score">{tile.value}</span>
                     </div>
                   ))}
                </div>
              )}

              {gameState.status === 'playing' && (
                <div className="controls">
                   <button className="btn btn-hint" onClick={useHint} title="Reveal one letter (-5 pts)">
                      ðŸ’¡ Hint (-5)
                   </button>
                   <button className="btn btn-secondary" onClick={skipWord}>Skip Word</button>
                </div>
              )}
            </>
          )
        )}
      </div>
    </>
  );
};

const root = createRoot(document.getElementById('app')!);
root.render(<App />);
